{"version":3,"file":"web-dialog.js","sources":["../node_modules/@a11y/focus-trap/focusable.js","../node_modules/@a11y/focus-trap/debounce.js","../node_modules/@a11y/focus-trap/focus-trap.js","../node_modules/@a11y/focus-trap/shadow.js","../node_modules/web-dialog/util.js","../node_modules/web-dialog/web-dialog.js","../node_modules/web-dialog/open-dialog.js"],"sourcesContent":["/**\n * Returns whether the element is hidden.\n * @param $elem\n */\nexport function isHidden($elem) {\n    return $elem.hasAttribute(\"hidden\")\n        || ($elem.hasAttribute(\"aria-hidden\") && $elem.getAttribute(\"aria-hidden\") !== \"false\")\n        // A quick and dirty way to check whether the element is hidden.\n        // For a more fine-grained check we could use \"window.getComputedStyle\" but we don't because of bad performance.\n        // If the element has visibility set to \"hidden\" or \"collapse\", display set to \"none\" or opacity set to \"0\" through CSS\n        // we won't be able to catch it here. We accept it due to the huge performance benefits.\n        || $elem.style.display === `none`\n        || $elem.style.opacity === `0`\n        || $elem.style.visibility === `hidden`\n        || $elem.style.visibility === `collapse`;\n    // If offsetParent is null we can assume that the element is hidden\n    // https://stackoverflow.com/questions/306305/what-would-make-offsetparent-null\n    //|| $elem.offsetParent == null;\n}\n/**\n * Returns whether the element is disabled.\n * @param $elem\n */\nexport function isDisabled($elem) {\n    return $elem.hasAttribute(\"disabled\")\n        || ($elem.hasAttribute(\"aria-disabled\") && $elem.getAttribute(\"aria-disabled\") !== \"false\");\n}\n/**\n * Determines whether an element is focusable.\n * Read more here: https://stackoverflow.com/questions/1599660/which-html-elements-can-receive-focus/1600194#1600194\n * Or here: https://stackoverflow.com/questions/18261595/how-to-check-if-a-dom-element-is-focusable\n * @param $elem\n */\nexport function isFocusable($elem) {\n    // Discard elements that are removed from the tab order.\n    if ($elem.getAttribute(\"tabindex\") === \"-1\" || isHidden($elem) || isDisabled($elem)) {\n        return false;\n    }\n    return (\n    // At this point we know that the element can have focus (eg. won't be -1) if the tabindex attribute exists\n    $elem.hasAttribute(\"tabindex\")\n        // Anchor tags or area tags with a href set\n        || ($elem instanceof HTMLAnchorElement || $elem instanceof HTMLAreaElement) && $elem.hasAttribute(\"href\")\n        // Form elements which are not disabled\n        || ($elem instanceof HTMLButtonElement\n            || $elem instanceof HTMLInputElement\n            || $elem instanceof HTMLTextAreaElement\n            || $elem instanceof HTMLSelectElement)\n        // IFrames\n        || $elem instanceof HTMLIFrameElement);\n}\n//# sourceMappingURL=focusable.js.map","const timeouts = new Map();\n/**\n * Debounces a callback.\n * @param cb\n * @param ms\n * @param id\n */\nexport function debounce(cb, ms, id) {\n    // Clear current timeout for id\n    const timeout = timeouts.get(id);\n    if (timeout != null) {\n        window.clearTimeout(timeout);\n    }\n    // Set new timeout\n    timeouts.set(id, window.setTimeout(() => {\n        cb();\n        timeouts.delete(id);\n    }, ms));\n}\n//# sourceMappingURL=debounce.js.map","import { debounce } from \"./debounce\";\nimport { isFocusable, isHidden } from \"./focusable\";\nimport { queryShadowRoot } from \"./shadow\";\n/**\n * Template for the focus trap.\n */\nconst template = document.createElement(\"template\");\ntemplate.innerHTML = `\n\t<div id=\"start\"></div>\n\t<div id=\"backup\"></div>\n\t<slot></slot>\n\t<div id=\"end\"></div>\n`;\n/**\n * Focus trap web component.\n * @customElement focus-trap\n * @slot - Default content.\n */\nexport class FocusTrap extends HTMLElement {\n    /**\n     * Attaches the shadow root.\n     */\n    constructor() {\n        super();\n        // The debounce id is used to distinguish this focus trap from others when debouncing\n        this.debounceId = Math.random().toString();\n        this._focused = false;\n        const shadow = this.attachShadow({ mode: \"open\" });\n        shadow.appendChild(template.content.cloneNode(true));\n        this.$backup = shadow.querySelector(\"#backup\");\n        this.$start = shadow.querySelector(\"#start\");\n        this.$end = shadow.querySelector(\"#end\");\n        this.focusLastElement = this.focusLastElement.bind(this);\n        this.focusFirstElement = this.focusFirstElement.bind(this);\n        this.onFocusIn = this.onFocusIn.bind(this);\n        this.onFocusOut = this.onFocusOut.bind(this);\n    }\n    // Whenever one of these attributes changes we need to render the template again.\n    static get observedAttributes() {\n        return [\n            \"inactive\"\n        ];\n    }\n    /**\n     * Determines whether the focus trap is active or not.\n     * @attr\n     */\n    get inactive() {\n        return this.hasAttribute(\"inactive\");\n    }\n    set inactive(value) {\n        value ? this.setAttribute(\"inactive\", \"\") : this.removeAttribute(\"inactive\");\n    }\n    /**\n     * Returns whether the element currently has focus.\n     */\n    get focused() {\n        return this._focused;\n    }\n    /**\n     * Hooks up the element.\n     */\n    connectedCallback() {\n        this.$start.addEventListener(\"focus\", this.focusLastElement);\n        this.$end.addEventListener(\"focus\", this.focusFirstElement);\n        // Focus out is called every time the user tabs around inside the element\n        this.addEventListener(\"focusin\", this.onFocusIn);\n        this.addEventListener(\"focusout\", this.onFocusOut);\n        this.render();\n    }\n    /**\n     * Tears down the element.\n     */\n    disconnectedCallback() {\n        this.$start.removeEventListener(\"focus\", this.focusLastElement);\n        this.$end.removeEventListener(\"focus\", this.focusFirstElement);\n        this.removeEventListener(\"focusin\", this.onFocusIn);\n        this.removeEventListener(\"focusout\", this.onFocusOut);\n    }\n    /**\n     * When the attributes changes we need to re-render the template.\n     */\n    attributeChangedCallback() {\n        this.render();\n    }\n    /**\n     * Focuses the first focusable element in the focus trap.\n     */\n    focusFirstElement() {\n        this.trapFocus();\n    }\n    /**\n     * Focuses the last focusable element in the focus trap.\n     */\n    focusLastElement() {\n        this.trapFocus(true);\n    }\n    /**\n     * Returns a list of the focusable children found within the element.\n     */\n    getFocusableElements() {\n        return queryShadowRoot(this, isHidden, isFocusable);\n    }\n    /**\n     * Focuses on either the last or first focusable element.\n     * @param {boolean} trapToEnd\n     */\n    trapFocus(trapToEnd) {\n        if (this.inactive)\n            return;\n        let focusableChildren = this.getFocusableElements();\n        if (focusableChildren.length > 0) {\n            if (trapToEnd) {\n                focusableChildren[focusableChildren.length - 1].focus();\n            }\n            else {\n                focusableChildren[0].focus();\n            }\n            this.$backup.setAttribute(\"tabindex\", \"-1\");\n        }\n        else {\n            // If there are no focusable children we need to focus on the backup\n            // to trap the focus. This is a useful behavior if the focus trap is\n            // for example used in a dialog and we don't want the user to tab\n            // outside the dialog even though there are no focusable children\n            // in the dialog.\n            this.$backup.setAttribute(\"tabindex\", \"0\");\n            this.$backup.focus();\n        }\n    }\n    /**\n     * When the element gains focus this function is called.\n     */\n    onFocusIn() {\n        this.updateFocused(true);\n    }\n    /**\n     * When the element looses its focus this function is called.\n     */\n    onFocusOut() {\n        this.updateFocused(false);\n    }\n    /**\n     * Updates the focused property and updates the view.\n     * The update is debounced because the focusin and focusout out\n     * might fire multiple times in a row. We only want to render\n     * the element once, therefore waiting until the focus is \"stable\".\n     * @param value\n     */\n    updateFocused(value) {\n        debounce(() => {\n            if (this.focused !== value) {\n                this._focused = value;\n                this.render();\n            }\n        }, 0, this.debounceId);\n    }\n    /**\n     * Updates the template.\n     */\n    render() {\n        this.$start.setAttribute(\"tabindex\", !this.focused || this.inactive ? `-1` : `0`);\n        this.$end.setAttribute(\"tabindex\", !this.focused || this.inactive ? `-1` : `0`);\n        this.focused ? this.setAttribute(\"focused\", \"\") : this.removeAttribute(\"focused\");\n    }\n}\nwindow.customElements.define(\"focus-trap\", FocusTrap);\n//# sourceMappingURL=focus-trap.js.map","/**\n * Traverses the slots of the open shadowroots and returns all children matching the query.\n * @param {ShadowRoot | HTMLElement} root\n * @param skipNode\n * @param isMatch\n * @param {number} maxDepth\n * @param {number} depth\n * @returns {HTMLElement[]}\n */\nexport function queryShadowRoot(root, skipNode, isMatch, maxDepth = 20, depth = 0) {\n    let matches = [];\n    // If the depth is above the max depth, abort the searching here.\n    if (depth >= maxDepth) {\n        return matches;\n    }\n    // Traverses a slot element\n    const traverseSlot = ($slot) => {\n        // Only check nodes that are of the type Node.ELEMENT_NODE\n        // Read more here https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n        const assignedNodes = $slot.assignedNodes().filter(node => node.nodeType === 1);\n        if (assignedNodes.length > 0) {\n            return queryShadowRoot(assignedNodes[0].parentElement, skipNode, isMatch, maxDepth, depth + 1);\n        }\n        return [];\n    };\n    // Go through each child and continue the traversing if necessary\n    // Even though the typing says that children can't be undefined, Edge 15 sometimes gives an undefined value.\n    // Therefore we fallback to an empty array if it is undefined.\n    const children = Array.from(root.children || []);\n    for (const $child of children) {\n        // Check if the node and its descendants should be skipped\n        if (skipNode($child)) {\n            continue;\n        }\n        // If the child matches we always add it\n        if (isMatch($child)) {\n            matches.push($child);\n        }\n        if ($child.shadowRoot != null) {\n            matches.push(...queryShadowRoot($child.shadowRoot, skipNode, isMatch, maxDepth, depth + 1));\n        }\n        else if ($child.tagName === \"SLOT\") {\n            matches.push(...traverseSlot($child));\n        }\n        else {\n            matches.push(...queryShadowRoot($child, skipNode, isMatch, maxDepth, depth + 1));\n        }\n    }\n    return matches;\n}\n//# sourceMappingURL=shadow.js.map","/**\n * Returns the data dialog count for an element.\n * @param $elem\n */\nfunction getDialogCount($elem) {\n    return Number($elem.getAttribute(`data-dialog-count`)) || 0;\n}\n/**\n * Sets the data dialog count for an element.\n * @param $elem\n * @param count\n */\nfunction setDialogCount($elem, count) {\n    $elem.setAttribute(`data-dialog-count`, count.toString());\n}\n/**\n * Traverses the tree of active elements down the shadow tree.\n * @param activeElement\n */\nfunction traverseActiveElements(activeElement = document.activeElement) {\n    if (activeElement != null && activeElement.shadowRoot != null && activeElement.shadowRoot.activeElement != null) {\n        return traverseActiveElements(activeElement.shadowRoot.activeElement);\n    }\n    return activeElement;\n}\n\nexport { getDialogCount, setDialogCount, traverseActiveElements };\n","import '@a11y/focus-trap';\nimport { traverseActiveElements, setDialogCount, getDialogCount } from './util.js';\n\nvar styles = `*{box-sizing:border-box}:host{padding:var(--dialog-container-padding,5vw 24px);z-index:var(--dialog-z-index,12345678);outline:none}#backdrop,:host{position:fixed;top:0;left:0;bottom:0;right:0}:host,:host([center]) #dialog{overflow-x:var(--dialog-overflow-x,hidden);overflow-y:var(--dialog-overflow-y,auto);overscroll-behavior:contain;-webkit-overflow-scrolling:touch}:host([center]){display:flex;align-items:center;justify-content:center;overflow:hidden}:host([center]) #dialog{max-height:var(--dialog-max-height,100%)}:host(:not(:defined)),:host(:not([open])){display:none}#backdrop{background:var(--dialog-backdrop-bg,rgba(0,0,0,.6));animation:fadeIn var(--dialog-animation-duration,.1s) var(--dialog-animation-easing,ease-out);z-index:-1}#dialog{animation:scaleIn var(--dialog-animation-duration,.1s) var(--dialog-animation-easing,ease-out);border-radius:var(--dialog-border-radius,12px);box-shadow:var(--dialog-box-shadow,0 2px 10px -5px rgba(0,0,0,.6));max-width:var(--dialog-max-width,700px);width:var(--dialog-width,100%);padding:var(--dialog-padding,24px);max-height:var(--dialog-max-height,unset);height:var(--dialog-height,auto);color:var(--dialog-color,currentColor);background:var(--dialog-bg,#fff);z-index:1;position:relative;display:flex;flex-direction:column;margin:0 auto;border:none}::slotted(article),article{flex-grow:1;overflow-y:auto;-webkit-overflow-scrolling:touch}::slotted(footer),::slotted(header),footer,header{flex-shrink:0}@keyframes scaleIn{0%{transform:scale(.9) translateY(30px);opacity:0}to{transform:scale(1) translateY(0);opacity:1}}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}`;\n\nconst template = document.createElement(\"template\");\ntemplate.innerHTML = `\n  <style>${styles}</style>\n  <div id=\"backdrop\" part=\"backdrop\"></div>\n  <focus-trap id=\"dialog\" part=\"dialog\">\n    <slot></slot>\n  </focus-trap>\n`;\n/**\n * A dialog web component that can be used to display highly interruptive messages.\n * @fires open - This event is fired when the dialog opens.\n * @fires close - This event is fired when the dialog closes.\n * @fires closing - This event is fired before the dialog is closed by clicking escape or on the backdrop. The event is cancellable which means `event.preventDefault()` can cancel the closing of the dialog.\n * @cssprop --dialog-container-padding - Padding of the host container of the dialog.\n * @cssprop --dialog-z-index - Z-index of the dialog.\n * @cssprop --dialog-overflow-x - Overflow of the x-axis.\n * @cssprop --dialog-overflow-y - Overflow of the y-axis.\n * @cssprop --dialog-max-height - Max height of the dialog.\n * @cssprop --dialog-height - Height of the dialog.\n * @cssprop --dialog-backdrop-bg - Background of the backdrop.\n * @cssprop --dialog-animation-duration - Duration of the dialog animation.\n * @cssprop --dialog-animation-easing - Easing of the dialog animation.\n * @cssprop --dialog-border-radius - Border radius of the dialog.\n * @cssprop --dialog-box-shadow - Box shadow of the dialog.\n * @cssprop --dialog-max-width - Max width of the dialog.\n * @cssprop --dialog-width - Width of the dialog.\n * @cssprop --dialog-padding - Padding of the dialog.\n * @cssprop --dialog-color - Color of the dialog.\n * @cssprop --dialog-bg - Background of the dialog.\n * @csspart backdrop - Backdrop part.\n * @csspart dialog - Dialog part.\n */\nclass WebDialog extends HTMLElement {\n    /**\n     * Attaches the shadow root.\n     */\n    constructor() {\n        super();\n        this.$scrollContainer = document.documentElement;\n        this.$previousActiveElement = null;\n        const shadow = this.attachShadow({ mode: \"open\" });\n        shadow.appendChild(template.content.cloneNode(true));\n        this.$dialog = shadow.querySelector(\"#dialog\");\n        this.$backdrop = shadow.querySelector(\"#backdrop\");\n        this.onBackdropClick = this.onBackdropClick.bind(this);\n        this.onKeyDown = this.onKeyDown.bind(this);\n        // Set aria attributes\n        this.setAttribute(\"aria-modal\", \"true\");\n        this.$dialog.setAttribute(\"role\", \"alertdialog\");\n    }\n    static get observedAttributes() {\n        return [\"open\", \"center\"];\n    }\n    /**\n     * Whether the dialog is opened.\n     * @attr\n     */\n    get open() {\n        return this.hasAttribute(\"open\");\n    }\n    set open(value) {\n        value ? this.setAttribute(\"open\", \"\") : this.removeAttribute(\"open\");\n    }\n    /**\n     * Whether the dialog is centered on the page.\n     * @attr\n     */\n    get center() {\n        return this.hasAttribute(\"center\");\n    }\n    set center(value) {\n        value ? this.setAttribute(\"center\", \"\") : this.removeAttribute(\"center\");\n    }\n    /**\n     * Attaches event listeners when connected.\n     */\n    connectedCallback() {\n        this.$backdrop.addEventListener(\"click\", this.onBackdropClick);\n    }\n    /**\n     * Removes event listeners when disconnected.\n     */\n    disconnectedCallback() {\n        this.$backdrop.removeEventListener(\"click\", this.onBackdropClick);\n        // If the dialog is open when it is removed from the DOM\n        // we need to cleanup the event listeners and side effects.\n        if (this.open) {\n            this.didClose();\n        }\n    }\n    /**\n     * Shows the dialog.\n     */\n    show() {\n        this.open = true;\n    }\n    /**\n     * Closes the dialog with a result.\n     * @param result\n     */\n    close(result) {\n        this.result = result;\n        this.open = false;\n    }\n    /**\n     * Closes the dialog when the backdrop is clicked.\n     */\n    onBackdropClick() {\n        if (this.assertClosing()) {\n            this.close();\n        }\n    }\n    /**\n     * Closes the dialog when escape is pressed.\n     */\n    onKeyDown(e) {\n        switch (e.code) {\n            case \"Escape\":\n                if (this.assertClosing()) {\n                    this.close();\n                    // If there are more dialogs, we don't want to close those also :-)\n                    e.stopImmediatePropagation();\n                }\n                break;\n        }\n    }\n    /**\n     * Dispatches an event that, if asserts whether the dialog can be closed.\n     * If \"preventDefault()\" is called on the event, assertClosing will return true\n     * if the event was not cancelled. It will return false if the event was cancelled.\n     */\n    assertClosing() {\n        return this.dispatchEvent(new CustomEvent(\"closing\", { cancelable: true }));\n    }\n    /**\n     * Setup the dialog after it has opened.\n     */\n    didOpen() {\n        // Save the current active element so we have a way of restoring the focus when the dialog is closed.\n        this.$previousActiveElement = traverseActiveElements(document.activeElement);\n        // Focus the first element in the focus trap.\n        // Wait for the dialog to show its content before we try to focus inside it.\n        // We request an animation frame to make sure the content is now visible.\n        requestAnimationFrame(() => {\n            this.$dialog.focusFirstElement();\n        });\n        // Make the dialog focusable\n        this.tabIndex = 0;\n        // Block the scrolling on the scroll container to avoid the outside content to scroll.\n        this.$scrollContainer.style.overflow = `hidden`;\n        // Listen for key down events to close the dialog when escape is pressed.\n        this.addEventListener(\"keydown\", this.onKeyDown, { capture: true, passive: true });\n        // Increment the dialog count with one to keep track of how many dialogs are currently nested.\n        setDialogCount(this.$scrollContainer, getDialogCount(this.$scrollContainer) + 1);\n        // Dispatch an event so the rest of the world knows the dialog opened.\n        this.dispatchEvent(new CustomEvent(\"open\"));\n    }\n    /**\n     * Clean up the dialog after it has closed.\n     */\n    didClose() {\n        // Remove the listener listening for key events\n        this.removeEventListener(\"keydown\", this.onKeyDown, { capture: true });\n        // Decrement the dialog count with one to keep track of how many dialogs are currently nested.\n        setDialogCount(this.$scrollContainer, Math.max(0, getDialogCount(this.$scrollContainer) - 1));\n        // If there are now 0 active dialogs we unblock the scrolling from the scroll container.\n        // This is because we know that no other dialogs are currently nested within the scroll container.\n        if (getDialogCount(this.$scrollContainer) <= 0) {\n            this.$scrollContainer.style.overflow = ``;\n        }\n        // Make the dialog unfocusable.\n        this.tabIndex = -1;\n        // Restore previous active element.\n        if (this.$previousActiveElement != null) {\n            this.$previousActiveElement.focus();\n            this.$previousActiveElement = null;\n        }\n        // Dispatch an event so the rest of the world knows the dialog closed.\n        // If a result has been set, the result is added to the detail property of the event.\n        this.dispatchEvent(new CustomEvent(\"close\", { detail: this.result }));\n    }\n    /**\n     * Reacts when an observed attribute changes.\n     */\n    attributeChangedCallback(name, newValue, oldValue) {\n        switch (name) {\n            case \"open\":\n                this.open ? this.didOpen() : this.didClose();\n                break;\n        }\n    }\n}\ncustomElements.define(\"web-dialog\", WebDialog);\n\nexport { WebDialog };\n","import '@a11y/focus-trap';\nimport { WebDialog } from './web-dialog.js';\nimport './util.js';\n\n/**\n * Opens a dialog and appends it to the container.\n * @param $content\n * @param $container\n * @param center\n * @param initialize\n */\nfunction openDialog({ $content, $container = document.body, center = false, initialize = (() => new WebDialog()) } = {}) {\n    // Construct the dialog.\n    const $dialog = initialize();\n    // Set the relevant properties of the dialog.\n    if (center != null) {\n        $dialog.center = center;\n    }\n    // Attach the content to the dialog.\n    if ($content != null) {\n        if (typeof $content === \"function\") {\n            $content($dialog);\n        }\n        else {\n            $dialog.appendChild($content);\n        }\n    }\n    // Create a resolver that resolves when the dialog closes.\n    const resolver = new Promise(res => {\n        $dialog.addEventListener(\"close\", (e) => {\n            $dialog.remove();\n            res(e.detail);\n        }, { once: true });\n    });\n    // Append the dialog to the container and open it.\n    $container.appendChild($dialog);\n    $dialog.show();\n    return { $dialog, resolver };\n}\n\nexport { openDialog };\n"],"names":["isHidden","$elem","hasAttribute","getAttribute","style","display","opacity","visibility","isFocusable","isDisabled","HTMLAnchorElement","HTMLAreaElement","HTMLButtonElement","HTMLInputElement","HTMLTextAreaElement","HTMLSelectElement","HTMLIFrameElement","timeouts","Map","template","document","createElement","innerHTML","FocusTrap","HTMLElement","[object Object]","super","this","debounceId","Math","random","toString","_focused","shadow","attachShadow","mode","appendChild","content","cloneNode","$backup","querySelector","$start","$end","focusLastElement","bind","focusFirstElement","onFocusIn","onFocusOut","observedAttributes","inactive","value","setAttribute","removeAttribute","focused","addEventListener","render","removeEventListener","trapFocus","queryShadowRoot","root","skipNode","isMatch","maxDepth","depth","matches","traverseSlot","$slot","assignedNodes","filter","node","nodeType","length","parentElement","children","Array","from","$child","push","shadowRoot","tagName","trapToEnd","focusableChildren","getFocusableElements","focus","updateFocused","cb","ms","id","timeout","get","window","clearTimeout","set","setTimeout","delete","debounce","getDialogCount","Number","setDialogCount","count","traverseActiveElements","activeElement","customElements","define","WebDialog","$scrollContainer","documentElement","$previousActiveElement","$dialog","$backdrop","onBackdropClick","onKeyDown","open","center","didClose","result","assertClosing","close","e","code","stopImmediatePropagation","dispatchEvent","CustomEvent","cancelable","requestAnimationFrame","tabIndex","overflow","capture","passive","max","detail","name","newValue","oldValue","didOpen","openDialog","$content","$container","body","initialize","resolver","Promise","res","remove","once","show"],"mappings":"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"}